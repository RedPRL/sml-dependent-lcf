This repository contains a collection of very modular libraries for building
tactic-based refiners in the LCF tradition.

### Dependent LCF: modernized refinement proof

Dependent LCF is a modernization of the old LCF tactic system, to deal with
dependent refinement properly. A proof state is a telescope of judgments, where
each judgment binds a metavariable in the rest of the telescope, together with
a term that takes its free metavariables from the telescope.

The telescope corresponds to the list of subgoals in LCF, and the open term
corresponds to the "validation" in LCF. Whereas in Classic LCF, the validation
was a computational function from evidence to evidence, here it is a piece of
evidence with free variables; this design choice is forced by the categorical
semantics for Dependent LCF, and suggests that the computational character of
validations in Classic LCF is a design which does not generalize cleanly.

#### correctness conditions

The correctness conditions of LCF refiners are usually said to be based on
having an abstract type of proofs ("evidence") that are synthesized, but this
is not part of the essence of LCF; indeed, in a system like Nuprl it is crucial
that this type not be abstract, since the synthesis of truth judgments is
simply another Nuprl term, which can be constructed by hand from anywhere.
Therefore, we may not in general view an LCF refiner as being in the business
of synthesizing proof: *proof is an act, not an object*.

[Randy Pollack](http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.29.9573)
includes the following in his list of ways a refiner may go wrong:

> It might return the wrong theorem [evidence]. ... We must execute a
> validation to completion and examine the `thm` [`evidence`] object it returns
> to be sure it is the intended one.

This is not in fact correct at all, at least, not from our perspective: a
refiner is a *definition* of a formal proof theory, and as such, whatever the
validation returns is the correct evidence *by definition*. Contrary to the
approach that has been taken with the Coq proof assistant, we intend a refiner
to be the definition of the proof theory, not a means to synthesize terms which
may be checked by a type checker, which is itself definitive.

The approach that we advocate scales better to larger objects, and is also
easier to verify: rules written for a refiner are usually very similar to how
they appear on paper, and it is easy to tell when they are correct. In
contrast, typecheckers are written at a far lower level of abstraction and are
more difficult to verify. It is clear that making the refiner definitive (and
thence trusted) is preferable to making the typechecker definitive (and thence
trusted), both in respect of correctness and in respect of real-world performance.


### Nominal LCF

Nominal LCF is a concrete language for refinement proof with well-scoped
hypothesis names. This is a non-trivial problem, because the binding of fresh
hypothesis names (e.g. as generated by a *left rule* in a sequent calculus) is
dependent on the goal at which a tactic is run. As a result, this is not a
static property, but a dynamic one.

Nominal LCF addresses this problem by construing tactics as consuming a free
choice sequence of atoms/symbols. A free choice sequence is like an infinite
stream, except its elements are got by interaction with a subject (i.e. a user)
rather than by means of a computable function.

The computability of nominal tactics allows us to calculate how much of the name
sequence a particular tactic has consumed (i.e. compute the modulus of
continuity of the stream processor), and use this in order to split the
sequence between tactics in order to ensure that names are consumed in the
right places when the script is run.

Nominal LCF may be elaborated into Dependent LCF using functors provided here.

-----------------------------------------------------------------------------------

### Instructions

```
git submodule init --recursive
rlwrap sml
> CM.make "development.cm";
```
