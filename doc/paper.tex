\documentclass[11pt]{article}

\usepackage[usenames,dvipsnames,svgnames,table]{xcolor}
\usepackage{amsmath, amsthm, stmaryrd, scalerel}
\usepackage{mathtools}
\usepackage{listings}
\usepackage{graphicx}
\usepackage{fontspec}
\usepackage{geometry}
\usepackage{proof}
\usepackage{supertabular}
\usepackage{unicode-math}
\usepackage{xltxtra}
\usepackage{xunicode}

\usepackage{setspace,url,hyperref}

% fonts
% \setromanfont[Mapping=tex-text, Ligatures=Rare, Numbers=OldStyle]{Linux Libertine O}
\setmathfont{Asana Math}

\newtheorem{thm}{Theorem}[section]
\newtheorem{prop}[thm]{Proposition}
\newtheorem{lem}[thm]{Lemma}
\newtheorem{cor}[thm]{Corollary}
\theoremstyle{definition}
\newtheorem{definition}[thm]{Definition}
\newtheorem{example}[thm]{Example}
\theoremstyle{remark}
\newtheorem{remark}[thm]{Remark}
\numberwithin{equation}{section}

\lstset{
  language=[Objective]Caml,
  extendedchars=\true,
  inputencoding=utf8,
  showspaces=false,
  showstringspaces=false,
  showtabs=false,
  basicstyle=\ttfamily,
  xleftmargin=6mm,
  framesep=4mm,
  moredelim=*[s][\itshape]{(*}{*)},
  moredelim=[is][\textcolor{darkgray}]{§}{§},
  escapechar=°,
  keywords=[6]{signature, structure, struct type, sig, end},
  keywordstyle=\color{MidnightBlue},
  stringstyle=\color[rgb]{0.545098, 0.278431, 0.364706},
  commentstyle=\color[rgb]{0.698039, 0.133333, 0.133333},
  numberstyle=\color[rgb]{0.372549, 0.619608, 0.627451},
  literate=
    {->}{{$\rightharpoonup$}}{1}
    {*}{{$\otimes$}}{1}
}


\def\InputModeColorName{MidnightBlue}
\def\OutputModeColorName{Maroon}
\newcommand\InputMode[1]{{\color{\InputModeColorName}{#1}}}
\newcommand\OutputMode[1]{{\color{\OutputModeColorName}{#1}}}
\newcommand\Quote[1]{{\color{Gray}{«}}#1{\color{Gray}{»}}}

\newcommand\HypJ[2]{#1\ \ (#2)}
\newcommand\GenJ[2]{\vert_{\InputMode{#1}}\; #2}
\newcommand\JJ{J}
\newcommand\Tuple[1]{\left\langle#1\right\rangle}
\newcommand\HTuple[1]{\left\lBrace#1\right\rBrace}
\newcommand\RSet{\mathfrak{R}}
\newcommand\JSet{\mathfrak{J}}

\newcommand\IsTac[1]{\InputMode{#1}\ \textit{tactic}}

%% subgoals
\newcommand\ISG[2]{\InputMode{#1}\,{\color{Black}:}\,\InputMode{#2}}
\newcommand\OSG[2]{\InputMode{#1}\,{\color{Black}:}\,\OutputMode{#2}}

%% refinement
\newcommand\Refine[4]{\InputMode{#1}\Vdash\InputMode{#2}\Rightarrow\OutputMode{#4}\dashv\OutputMode{#3}}
\newcommand\NoRefine[2]{\InputMode{#1}\Vdash\InputMode{#2}\Uparrow}

\newcommand\ThenStateTrans[5]{%
  \InputMode{#2}\dashv\InputMode{#3}%
  \Downarrow_\InputMode{#1}%
  \OutputMode{#4}\dashv\OutputMode{#5}%
}

\newcommand\Member[2]{\InputMode{#1}\in\InputMode{#2}}
\newcommand\MemberUnmoded[2]{#1\in #2}
\newcommand\IsTrue[1]{\InputMode{#1}\ \textit{true}}
\newcommand\IsTrueUnmoded[1]{#1\ \textit{true}}
\newcommand\IdTac{\mathtt{id}}
\newcommand\FailTac{\mathtt{fail}}
\newcommand\OrElseTac[2]{#1\vert#2}
\newcommand\ThenTac[2]{#1;#2}
\newcommand\ThenLTac[2]{#1;[#2]}
\newcommand\DProdIntroRule[1]{\mathtt{PairIntro}\{#1\}}
\newcommand\DProdIntroRuleNullary{\mathtt{PairIntro}}
\newcommand\TyProd[2]{#1 \times #2}
\newcommand\TyDProd[3]{(#2:#1) \times #3}
\newcommand\TyMember[2]{#1\in#2}
\newcommand\Dom[1]{\left\vert#1\right\vert}
\newcommand\SubsetEq[2]{\InputMode{#1}\subseteq\InputMode{#2}}
\newcommand\FV[1]{\textit{FV}\left(#1\right)}
\newcommand\Subst[3]{\left[#1\;/\;#2\right]#3}
\newcommand\ModLCF{\textbf{\emph{Modernized LCF}}}
\newcommand\DepLCF{\textbf{\emph{Dependent LCF}}}

\begin{document}

\title{Dependency in Refinement Logics}
\date{}
\author{Jonathan Sterling}
\maketitle

\begin{abstract}

  We propose a new generalization of LCF-style refinement logics called \DepLCF,
  which allows the definition of refinement rules which express a dependency
  between subgoals, without the use of unification variables.

\end{abstract}

Over the past four decades, there have been many incarnations of the \emph{LCF}
(Logic for Computable Functions) interface, but the one that will concern us
here is its extension to \emph{LCF with Validations} as found in Cambridge LCF,
which outfits the proving activity with the synthesis of explicit evidence.
The Cambridge LCF signature is as follows:

%% cite "Logic and Computation: Interactive Proof with Cambridge LCF"

\begin{lstlisting}
  signature CAMBRIDGE_LCF =
  sig
    type form
    type thm
    type proof = thm list -> thm
    type goal = form list * form
    type tactic = goal -> goal list * proof
  end
\end{lstlisting}

The \verb!goal! type represents sequents, where \verb!form! represents logical
propositions. The LCF methodology, however, may be used to give a refinement
treatment to many kinds of judgments, not just sequents; therefore, it
is better to not include this in the core signature at all, and make the
type of judgments abstract; for clarity, we will replace the name \verb!thm!
with \verb!synthesis!.

\begin{lstlisting}
  signature LCF =
  sig
    type judgment
    type synthesis
    type proof = synthesis list -> synthesis
    type tactic = judgment -> judgment list * proof
  end
\end{lstlisting}

Then, a tactic is something that refines a judgment to a list of judgments (its
subgoals), and synthesizes its evidence (provided the syntheses of its
subgoals). There are many different tactics which can be implemented
generically over this signature; here are a few:

\begin{lstlisting}
  signature TACTICALS =
  sig
    structure Lcf : LCF
    val ID : Lcf.tactic
    val FAIL : Lcf.tactic
    val THEN : Lcf.tactic * Lcf.tactic -> Lcf.tactic
    val THENL : Lcf.tactic * Lcf.tactic list -> Lcf.tactic
  end
\end{lstlisting}

\section{\ModLCF: the logic of tactics}

In order to study the design space for LCF refiners, we would like to give a
judgmental characterization of tactic systems, which we will call $\ModLCF$.
To begin with, note that the type of validations (\verb!proof!) in the ML
implementation is essentially a HOAS (higher-order abstract syntax) encoding
of a hypothetical proof or synthesis of a judgment.  With this insight in hand,
we are in a position to unify the list of subgoals and the validation generated
by a tactic into a single concept, namely that of a \emph{hypothetical proof}
$E$ whose free variables are explained in a context $\Psi$ of subgoals.

To make the preceding observations precise, we can characterize the behavior of
a \ModLCF\ refiner judgmentally via two forms of judgment,
\framebox{$\Refine{\JJ}{\tau}{\Psi}{E}$} and \framebox{$\NoRefine{\JJ}{\tau}$}, where $\JJ$ is a judgment of the
logical theory, $\tau$ is a tactic, $\Psi$ is a context of judgments,
representing the subgoals generated by the tactic $\tau$, and $E$ is the
synthesis of the judgment $\JJ$, binding variables $\Dom{\Psi}$ which represent
the syntheses of the subgoals.

The meaning of $\Refine{\JJ}{\tau}{\Psi}{E}$ is that $\tau$ is applicable to
demonstrating the judgment $\JJ$, producing synthesis $e$ under the assumptions
that the judgments in $\Psi$ can be demonstrated. The divergence judgment
$\NoRefine{\JJ}{\tau}$ expresses the inapplicability of $\tau$ to $\JJ$.  In
practice, we will explain only the assertion conditions for one of
$\Refine{\JJ}{\tau}{\Psi}{E}$ and $\NoRefine{\JJ}{\tau}$, and implicitly take
the other to be its complement.

\begin{remark}
  The refinement judgments $\Refine{\JJ}{\tau}{\Psi}{E}$ and
  $\NoRefine{\JJ}{\tau}$ are not higher-order judgments, because the variable
  $\JJ$ ranges not over judgments of the refinement theory, but of the
  object theory.
\end{remark}


Let $\JSet$ be the open-ended collection of judgments in our logical theory,
and let $\RSet$ be a collection of rule names. Each rule $\Member{R}{\RSet}$
must be interpretable as a tactic, i.e.\ the meaning of the assertions
$\Refine{\JJ}{R}{\Psi}{E}$ and $\NoRefine{\JJ}{R}$ must be explained for
$\Member{J}{\JSet}$. We say \framebox{$\IsTac{\tau}$} in case for all object-judgments
$\Member{\JJ}{\JSet}$, the assertion conditions for
$\Refine{\JJ}{\tau}{\Psi}{E}$ and $\NoRefine{\JJ}{\tau}$ are disjoint, and
moreover, if $\Refine{\JJ}{\tau}{\Psi}{E}$, then
$\SubsetEq{\FV{E}}{\Dom{\Psi}}$.

Numerous general purpose tactics can be defined over a logical theory,
including identity, failure, disjunction and sequencing:

\begin{gather*}
  \infer{
    \Refine{\JJ}{\IdTac}{\OSG{\alpha}{\JJ}}{\alpha}
  }{
  }
  \qquad
  \infer{
    \NoRefine{\JJ}{\FailTac}
  }{
  }\\[6pt]
  \infer{
    \Refine{\JJ}{\OrElseTac{\tau_1}{\tau_2}}{\Psi}{E}
  }{
    \Refine{\JJ}{\tau_1}{\Psi}{E}
  }
  \qquad
  \infer{
    \Refine{\JJ}{\OrElseTac{\tau_1}{\tau_2}}{\Psi}{E}
  }{
    \NoRefine{\JJ}{\tau_1} &
    \Refine{\JJ}{\tau_2}{\Psi}{E}
  }\\[6pt]
  \infer{
    \Refine{\JJ}{\ThenTac{\tau_1}{\tau_2}}{\bigoplus_{\Dom\Phi}\Psi}{\Subst{F}{\Dom\Phi}{E}}
  }{
    \Refine{\JJ}{\tau_1}{\Phi}{E} &
    \GenJ{\alpha}{
      \HypJ{
        \Refine{\Phi(\alpha)}{\tau_2}{\Psi_\alpha}{F_\alpha}
      }{
        \Member{\alpha}{\Dom\Phi}
      }
    }
  }
\end{gather*}

\begin{remark}
  The nominal treatment that we have given here allows for a much more
  economical presentation of the standard tacticals, which are quite ardruous
  to define in the HOAS treatment used in ML implementations.
\end{remark}

\begin{thm}
  The above rules all define valid tactics:.
  \begin{enumerate}
    \item $\IsTac{\IdTac}$.
    \item $\IsTac{\FailTac}$.
    \item If $\IsTac{\tau_1}$ and $\IsTac{\tau_2}$, then
      $\IsTac{\OrElseTac{\tau_1}{\tau_2}}$.
    \item If $\IsTac{\tau_1}$ and $\IsTac{\tau_2}$, then
      $\IsTac{\ThenTac{\tau_1}{\tau_2}}$.
  \end{enumerate}
\end{thm}
\begin{proof}
  It suffices to verify that the synthesis $E$ of each tactical is well-scoped
  in $\Psi$; in each case, this follows by induction.
  \begin{enumerate}
    \item[(1--2)] Immediate.
    \item[(3)]
      By induction on derivations of
      $\Refine{\JJ}{\OrElseTac{\tau_1}{\tau_1}}{E}{\Psi}$.
      \begin{description}
        \item[Case $\Refine{\JJ}{\tau_1}{\Psi}{E}$.] Validity follows from the
          inductive hypothesis $\IsTac{\tau_1}$.
        \item[Case $\NoRefine{\JJ}{\tau_1}$.] Validity follows from the
          inductive hypothesis $\IsTac{\tau_2}$.
      \end{description}

    \item[(4)] We need to show that
      $\SubsetEq{\FV{\Subst{F}{\Dom\Phi}{E}}}{\Dom{\bigoplus_{\Dom\Phi}\Psi}}$.
      From our inductive hypotheses, it is evident that
      $\SubsetEq{\FV{E}}{\Dom\Phi}$ and that for each $\Member{\alpha}{\Phi}$,
      $\SubsetEq{\FV{F_\alpha}}{\Dom{\Psi_\alpha}}$; all of the free variables
      of the term got by substituting each $F_\alpha$ for
      $\Member{\alpha}{\Dom\Phi}$ clearly reside in one of the fibres of the
      family of contexts $\Psi$, and so they must comprise a subset of the
      union $\bigoplus_{\Dom\Phi}\Psi$ of $\Psi$'s fibres.

  \end{enumerate}
\end{proof}

\section{\ModLCF\ and the constructible subgoals property}

An LCF-style refiner has a property called \emph{constructible subgoals}, which
means that the subgoals incurred by a rule or tactic may be constructed
independently, using only the statement of the main goal. One unfortunate
consequence of this principle is that it is impossible to define a refinement
rule which expresses a dependency between subgoals. The canonical example is
the introduction rule for dependent pairs in Type Theory:
\[
  \infer[\textit{PairIntro}]{
    \Member{\Tuple{M,N}}{\TyDProd{A}{x}{B}}
  }{
    \Member{M}{A} &
    \Member{N}{\Subst{M}{x}{B}}
  }
\]

However, consider what a refinement rule for this would look like; we would
like to take the goal $\IsTrue{\TyDProd{A}{x}{B}}$ to two subgoals (one for
each conjunct); the first subgoal $\IsTrue{A}$ is clear enough, but it is not
possible to even write down the second subgoal until we know the synthesis of
the first one.

Because a tactic in \ModLCF\ produces only a \emph{context} of independent
subgoals, we cannot give a refinement treatment to this rule, and must
instead write a family of refinement rules $\DProdIntroRule{w}$ fibred over
witnesses of the left conjunct $w$:

\[
  \Refine{\IsTrueUnmoded{\TyDProd{A}{x}{B}}}{\DProdIntroRule{w}}{%
    \left\{\begin{array}{l}
      \OSG{\alpha}{\MemberUnmoded{w}{A}}\\
      \OSG{\beta}{\IsTrueUnmoded{\Subst{w}{x}{B}}}
    \end{array}\right.
  }{\Tuple{w,\beta}}
\]

This is clearly unsatisfactory, since it breaks the natural flow of proof
development, whereby multiple goals may be refined simultaneously without
committing in advance to a particular solution. However, a more palatable
rule that allows $\IsTrue{A}$ to be demonstrated by refinement is
simply not expressible in \ModLCF, since the sense of the second subgoal cannot
be expressed except by referring to the synthesis of the first subgoal.

\section{\DepLCF\ and generalized refinement rules}

At the crux of our problem is the fact that a tactic produces a context of subgoals
without any dependencies; if we were to construe the judgment
$\Refine{\JJ}{\tau}{\Psi}{E}$ as synthesizing a \emph{telescope} $\Psi$ rather
than a mere context, a proper refinement rule for \emph{PairIntro} would be
within reach. In fact, whilst the ML signature for LCF refiners rules out this
interpretation, the notation we have used for \ModLCF\ immediately suggests
this generalization. Going forward, we will call the theory \DepLCF\ when we
take $\Psi$ to be a telescope rather than a context.

We can now encode \emph{PairIntro} with a single refinement rule,
$\DProdIntroRuleNullary$:

\[
  \Refine{\IsTrueUnmoded{\TyDProd{A}{x}{B}}}{\DProdIntroRuleNullary}{%
    \left\{\begin{array}{l}
        \OSG{\alpha}{\IsTrueUnmoded{A}}\\
        \OSG{\beta}{\IsTrueUnmoded{\Subst{\alpha}{x}{B}}}
    \end{array}\right.
  }{
    \Tuple{\alpha,\beta}
  }
\]

All that remains is to give a new definition of the sequencing tactical
$\ThenTac{\tau_1}{\tau_2}$ which accounts for this dependency. In order to do
this, we will need to implement an auxiliary judgment
\framebox{$\ThenStateTrans{\tau}{E}{\Phi}{E'}{\Phi'}$} that allows us to
gradually apply the tactic $\tau$ to a proof state, propagating refinements
rightward through substitution. This judgment is defined by recursion on the
telescope $\Phi$, viewed as a \emph{cons}-list:

\begin{gather*}
  \infer{
    \ThenStateTrans{\tau}{E}{\cdot}{E}{\cdot}
  }{
  }\\[6pt]
  \infer{
    \ThenStateTrans{\tau}{E}{\ISG{\alpha}{\JJ},\Phi}{E'}{\Psi_\alpha\oplus\Phi'}
  }{
    \Refine{\JJ}{\tau}{\Psi_\alpha}{E_\alpha} &
    \ThenStateTrans{\tau}{%
      \Subst{E_\alpha}{\alpha}{E}%
    }{
      \Subst{E_\alpha}{\alpha}{\Phi}
    }{E'}{\Phi'}
  }
\end{gather*}

Now, the sequencing tactical is readily definable:
\[
  \infer{
    \Refine{\JJ}{\ThenTac{\tau_1}{\tau_2}}{\Phi'}{E'}
  }{
    \Refine{\JJ}{\tau_1}{\Phi}{E} &
    \ThenStateTrans{\tau_2}{E}{\Phi}{E'}{\Phi'}
  }
\]

\section{ML Implementation of \DepLCF}

\end{document}
